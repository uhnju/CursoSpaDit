<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curso Avanzado de React: Hooks y Conceptos Fundamentales</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1, h2, h3 {
            color: #333;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        .section {
            margin-bottom: 40px;
        }
        .index {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .index a {
            color: #007BFF;
            text-decoration: none;
        }
        .index a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>

    <h1>Curso Avanzado de React: Hooks y Conceptos Fundamentales</h1>
    <p>Esta documentación está diseñada para complementar el curso avanzado de React, proporcionando explicaciones detalladas, pedagógicas y ampliadas de los hooks y técnicas más comunes. Cada sección incluye sintaxis, ejemplos de uso, aplicaciones reales y consideraciones clave para que el alumno entienda tanto el "qué" como el "por qué" de cada herramienta.</p>

    <!-- Índice -->
    <div class="index">
        <h2>Índice</h2>
        <ul>
            <li><a href="#jsx">01. Introducción a JSX</a></li>
            <li><a href="#props">02. Uso de props y componentes reutilizables</a></li>
            <li><a href="#renderizado-condicional">03. Renderizado condicional</a></li>
            <li><a href="#renderizado-listas">04. Renderizado de listas</a></li>
            <li><a href="#eventos">05. Manejo de eventos</a></li>
            <li><a href="#useState">06. Estado con useState</a></li>
            <li><a href="#useEffect">07. Efectos secundarios con useEffect</a></li>
            <li><a href="#api-requests">08. Peticiones a APIs</a></li>
            <li><a href="#useRef">09. Referencias y persistencia con useRef</a></li>
            <li><a href="#useContext">10. Contexto global con useContext</a></li>
            <li><a href="#router">11. Navegación con React Router</a></li>
            <li><a href="#useParams">12. Parámetros de ruta con useParams</a></li>
            <li><a href="#useReducer">13. Estados complejos con useReducer</a></li>
            <li><a href="#storage">14. Persistencia con localStorage y sessionStorage</a></li>
            <li><a href="#tsx">15. Introducción a React con TypeScript</a></li>
        </ul>
    </div>

    <!-- Sección 1: Introducción a JSX -->
    <div class="section" id="jsx">
        <h2>01. Introducción a JSX</h2>
        <p><strong>Definición:</strong> JSX es una extensión de sintaxis que permite escribir HTML dentro de JavaScript. Es una característica fundamental de React que facilita la creación de interfaces de usuario.</p>
        <p><strong>Reglas básicas:</strong></p>
        <ul>
            <li>Los componentes deben devolver un único elemento padre. Usa fragmentos (<code>&lt;&gt;...&lt;/&gt;</code>) si no quieres agregar un <code>div</code> adicional.</li>
            <li>Las expresiones JavaScript se escriben entre <code>{}</code>.</li>
            <li>Atributos como <code>class</code> pasan a ser <code>className</code>.</li>
            <li>Los nombres de componentes deben comenzar con mayúscula.</li>
        </ul>
        <p><strong>Ejemplo:</strong></p>
        <pre><code>
const nombre = "React";
return (
  &lt;div className="container"&gt;
    &lt;h1&gt;Hola, {nombre}&lt;/h1&gt;
    &lt;p&gt;Este es un ejemplo de JSX.&lt;/p&gt;
  &lt;/div&gt;
);
        </code></pre>
        <p><strong>Consideraciones avanzadas:</strong></p>
        <ul>
            <li><strong>Fragments:</strong> Usa <code>&lt;&gt;...&lt;/&gt;</code> para evitar elementos innecesarios en el DOM.</li>
            <li><strong>Expresiones condicionales:</strong> Puedes usar operadores ternarios o lógicos dentro de JSX.</li>
            <li><strong>Componentes dinámicos:</strong> Puedes renderizar componentes dinámicamente usando expresiones.</li>
        </ul>
        <p><strong>Ejemplo avanzado:</strong></p>
        <pre><code>
const ComponenteDinamico = ({ tipo }) => {
  const Componente = tipo === 'A' ? ComponenteA : ComponenteB;
  return &lt;Componente /&gt;;
};
        </code></pre>
    </div>

    <!-- Sección 2: Uso de props y componentes reutilizables -->
    <div class="section" id="props">
        <h2>02. Uso de props y componentes reutilizables</h2>
        <p><strong>Definición:</strong> Las props (propiedades) son el mecanismo para pasar datos desde un componente padre hacia sus hijos. Permiten crear componentes reutilizables y modulares.</p>
        <p><strong>Ejemplo:</strong></p>
        <pre><code>
const Saludo = ({ nombre, edad }) => (
  &lt;div&gt;
    &lt;h1&gt;Hola, {nombre}&lt;/h1&gt;
    {edad && &lt;p&gt;Tienes {edad} años.&lt;/p&gt;}
  &lt;/div&gt;
);

&lt;Saludo nombre="Juan" edad={25} /&gt;
        </code></pre>
        <p><strong>Características avanzadas:</strong></p>
        <ul>
            <li><strong>PropTypes:</strong> Usa <code>PropTypes</code> para validar las props y evitar errores.</li>
            <li><strong>Default Props:</strong> Define valores predeterminados para las props.</li>
            <li><strong>Children:</strong> Usa <code>props.children</code> para pasar elementos hijos a un componente.</li>
        </ul>
        <p><strong>Ejemplo avanzado:</strong></p>
        <pre><code>
const Tarjeta = ({ titulo, children }) => (
  &lt;div className="tarjeta"&gt;
    &lt;h2&gt;{titulo}&lt;/h2&gt;
    {children}
  &lt;/div&gt;
);

&lt;Tarjeta titulo="Título de la tarjeta"&gt;
  &lt;p&gt;Contenido de la tarjeta.&lt;/p&gt;
&lt;/Tarjeta&gt;
        </code></pre>
    </div>

    <!-- Sección 3: Renderizado condicional -->
    <div class="section" id="renderizado-condicional">
        <h2>03. Renderizado condicional</h2>
        <p><strong>Definición:</strong> El renderizado condicional permite mostrar u ocultar componentes o elementos del DOM en función de una condición lógica. Es esencial para construir interfaces dinámicas.</p>
        <p><strong>Sintaxis común:</strong></p>
        <pre><code>
{condición ? &lt;ComponenteA /&gt; : &lt;ComponenteB /&gt;}
{condición && &lt;Componente /&gt;}
        </code></pre>
        <p><strong>Ejemplo práctico:</strong></p>
        <pre><code>
const LoginStatus = ({ isLoggedIn }) => {
  return (
    &lt;div&gt;
      {isLoggedIn ? &lt;p&gt;Bienvenido de nuevo&lt;/p&gt; : &lt;p&gt;Por favor, inicia sesión&lt;/p&gt;}
    &lt;/div&gt;
  );
};
        </code></pre>
        <p><strong>Consideraciones avanzadas:</strong></p>
        <ul>
            <li><strong>Renderizado condicional anidado:</strong> Puedes combinar múltiples condiciones para renderizar componentes complejos.</li>
            <li><strong>Componentes de carga:</strong> Usa el renderizado condicional para mostrar un spinner mientras se cargan los datos.</li>
            <li><strong>Manejo de errores:</strong> Renderiza un mensaje de error si algo falla.</li>
        </ul>
        <p><strong>Ejemplo avanzado:</strong></p>
        <pre><code>
const EstadoCarga = ({ isLoading, error, data }) => {
  if (isLoading) return &lt;Spinner /&gt;;
  if (error) return &lt;p&gt;Error: {error.message}&lt;/p&gt;;
  return &lt;Datos data={data} /&gt;;
};
        </code></pre>
    </div>

    <!-- Sección 4: Renderizado de listas -->
    <div class="section" id="renderizado-listas">
        <h2>04. Renderizado de listas</h2>
        <p><strong>Definición:</strong> Renderizar listas permite mostrar colecciones de datos como elementos individuales (cards, filas, etc.). Se hace comúnmente usando <code>Array.map()</code>.</p>
        <p><strong>Sintaxis básica:</strong></p>
        <pre><code>
{elementos.map((item) => (
  &lt;Elemento key={item.id} {...item} /&gt;
))}
        </code></pre>
        <p><strong>Ejemplo práctico:</strong></p>
        <pre><code>
const ListaUsuarios = ({ usuarios }) => {
  return (
    &lt;ul&gt;
      {usuarios.map(usuario => (
        &lt;li key={usuario.id}&gt;{usuario.nombre}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};
        </code></pre>
        <p><strong>Consideraciones avanzadas:</strong></p>
        <ul>
            <li><strong>Virtualización:</strong> Para listas grandes, usa bibliotecas como <code>react-window</code> o <code>react-virtualized</code> para mejorar el rendimiento.</li>
            <li><strong>Paginación:</strong> Implementa paginación para manejar grandes conjuntos de datos.</li>
            <li><strong>Filtrado y ordenación:</strong> Aplica filtros y ordenación a las listas antes de renderizarlas.</li>
        </ul>
        <p><strong>Ejemplo avanzado:</strong></p>
        <pre><code>
const ListaFiltrada = ({ usuarios, filtro }) => {
  const usuariosFiltrados = usuarios.filter(usuario => usuario.nombre.includes(filtro));
  return (
    &lt;ul&gt;
      {usuariosFiltrados.map(usuario => (
        &lt;li key={usuario.id}&gt;{usuario.nombre}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};
        </code></pre>
    </div>

    <!-- Sección 5: Manejo de eventos -->
    <div class="section" id="eventos">
        <h2>05. Manejo de eventos</h2>
        <p><strong>Definición:</strong> El manejo de eventos permite a la interfaz responder a las acciones del usuario, como clics, escritura, movimientos del ratón, etc.</p>
        <p><strong>Ejemplo:</strong></p>
        <pre><code>
&lt;button onClick={() => alert("¡Hola!")}&gt;Haz clic&lt;/button&gt;
&lt;input onChange={(e) => console.log(e.target.value)} /&gt;
        </code></pre>
        <p><strong>Eventos comunes:</strong></p>
        <ul>
            <li><code>onClick</code>, <code>onChange</code>, <code>onSubmit</code></li>
            <li><code>onKeyDown</code>, <code>onKeyUp</code>, <code>onMouseOver</code></li>
        </ul>
        <p><strong>Consideraciones avanzadas:</strong></p>
        <ul>
            <li><strong>Eventos sintéticos:</strong> React normaliza los eventos para que funcionen de manera consistente en todos los navegadores.</li>
            <li><strong>Paso de parámetros:</strong> Puedes pasar parámetros a los manejadores de eventos usando funciones flecha.</li>
            <li><strong>Prevención de comportamientos predeterminados:</strong> Usa <code>e.preventDefault()</code> para evitar comportamientos predeterminados del navegador.</li>
        </ul>
        <p><strong>Ejemplo avanzado:</strong></p>
        <pre><code>
const ManejadorClick = (id) => {
  console.log(`Elemento con ID ${id} fue clickeado.`);
};

&lt;button onClick={() => ManejadorClick(1)}&gt;Clic aquí&lt;/button&gt;
        </code></pre>
    </div>

    <!-- Sección 6: Estado con useState -->
    <div class="section" id="useState">
        <h2>06. Estado con useState</h2>
        <p><strong>Definición:</strong> <code>useState</code> es el hook más fundamental en React. Permite a un componente funcional mantener valores que cambian con el tiempo (estado). Cada vez que el estado cambia, el componente se vuelve a renderizar con el nuevo valor.</p>
        <p><strong>Sintaxis básica:</strong></p>
        <pre><code>const [estado, setEstado] = useState(valorInicial);</code></pre>
        <ul>
            <li><code>estado</code>: es la variable que contiene el valor actual.</li>
            <li><code>setEstado</code>: función que actualiza el valor y provoca un nuevo render.</li>
        </ul>
        <p><strong>Ejemplo básico:</strong></p>
        <pre><code>
const [contador, setContador] = useState(0);

return (
  &lt;div&gt;
    &lt;p&gt;Contador: {contador}&lt;/p&gt;
    &lt;button onClick={() => setContador(contador + 1)}&gt;Sumar&lt;/button&gt;
  &lt;/div&gt;
);
        </code></pre>
        <p><strong>Consideraciones avanzadas:</strong></p>
        <ul>
            <li><strong>Inicialización perezosa:</strong> Usa una función para inicializar el estado si el cálculo es costoso.</li>
            <li><strong>Estado complejo:</strong> Para estados complejos, considera usar <code>useReducer</code>.</li>
            <li><strong>Actualizaciones basadas en el estado anterior:</strong> Usa la forma funcional de <code>setEstado</code> para evitar problemas de asincronía.</li>
        </ul>
        <p><strong>Ejemplo avanzado:</strong></p>
        <pre><code>
const [contador, setContador] = useState(() => {
  const inicial = calcularValorInicial();
  return inicial;
});

setContador(prevContador => prevContador + 1);
        </code></pre>
    </div>

    <!-- Sección 7: Efectos secundarios con useEffect -->
    <div class="section" id="useEffect">
        <h2>07. Efectos secundarios con useEffect</h2>
        <p><strong>Definición:</strong> <code>useEffect</code> permite ejecutar efectos secundarios en un componente: peticiones HTTP, suscripciones, manipulación del DOM, timers, etc. Reemplaza los métodos <code>componentDidMount</code>, <code>componentDidUpdate</code> y <code>componentWillUnmount</code> de las clases.</p>
        <p><strong>Sintaxis básica:</strong></p>
        <pre><code>
useEffect(() => {
  // Efecto
  return () => {
    // Limpieza (opcional)
  };
}, [dependencias]);
        </code></pre>
        <p><strong>Tipos de dependencias:</strong></p>
        <ul>
            <li>Sin dependencias: se ejecuta tras cada renderizado.</li>
            <li><code>[]</code>: solo una vez al montar el componente.</li>
            <li><code>[x, y]</code>: cuando cambian esas variables.</li>
        </ul>
        <p><strong>Ejemplo con document.title:</strong></p>
        <pre><code>
useEffect(() => {
  document.title = `Has hecho clic ${contador} veces`;
}, [contador]);
        </code></pre>
        <p><strong>Consideraciones avanzadas:</strong></p>
        <ul>
            <li><strong>Limpieza de efectos:</strong> Siempre limpia los efectos secundarios para evitar fugas de memoria.</li>
            <li><strong>AbortController:</strong> Usa <code>AbortController</code> para cancelar peticiones fetch cuando el componente se desmonta.</li>
            <li><strong>Optimización de rendimiento:</strong> Evita efectos innecesarios para no sobrecargar el renderizado.</li>
        </ul>
        <p><strong>Ejemplo avanzado:</strong></p>
        <pre><code>
useEffect(() => {
  const controller = new AbortController();
  const signal = controller.signal;

  fetch("https://api.example.com/data", { signal })
    .then(response => response.json())
    .then(data => setData(data))
    .catch(error => console.error(error));

  return () => controller.abort();
}, []);
        </code></pre>
    </div>

    <!-- Sección 8: Peticiones a APIs -->
    <div class="section" id="api-requests">
        <h2>08. Peticiones a APIs</h2>
        <p><strong>Definición:</strong> Las peticiones a APIs permiten que la aplicación React obtenga o envíe datos a servidores. Se realizan normalmente desde <code>useEffect</code>.</p>
        <p><strong>Con fetch:</strong></p>
        <pre><code>
useEffect(() => {
  fetch("https://api.example.com/users")
    .then(res => res.json())
    .then(data => setUsuarios(data))
    .catch(error => console.error(error));
}, []);
        </code></pre>
        <p><strong>Con axios:</strong></p>
        <pre><code>
import axios from 'axios';

useEffect(() => {
  axios.get("https://api.example.com/users")
    .then(response => setUsuarios(response.data))
    .catch(error => console.error(error));
}, []);
        </code></pre>
        <p><strong>Consideraciones avanzadas:</strong></p>
        <ul>
            <li><strong>Manejo de estados de carga y error:</strong> Usa estados para manejar la carga y los errores de las peticiones.</li>
            <li><strong>Cancelación de peticiones:</strong> Usa <code>AbortController</code> para cancelar peticiones cuando el componente se desmonta.</li>
            <li><strong>Memoización:</strong> Evita peticiones duplicadas usando memoización.</li>
        </ul>
        <p><strong>Ejemplo avanzado:</strong></p>
        <pre><code>
const [usuarios, setUsuarios] = useState([]);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const controller = new AbortController();
  const signal = controller.signal;

  setLoading(true);
  fetch("https://api.example.com/users", { signal })
    .then(res => res.json())
    .then(data => {
      setUsuarios(data);
      setLoading(false);
    })
    .catch(error => {
      if (error.name !== 'AbortError') {
        setError(error);
        setLoading(false);
      }
    });

  return () => controller.abort();
}, []);
        </code></pre>
    </div>

    <!-- Sección 9: Referencias y persistencia con useRef -->
    <div class="section" id="useRef">
        <h2>09. Referencias y persistencia con useRef</h2>
        <p><strong>Definición:</strong> <code>useRef</code> permite crear una referencia mutable que persiste entre renderizados. Es útil para acceder a elementos del DOM o almacenar valores que no deben provocar re-renderizados.</p>
        <p><strong>Ejemplo:</strong></p>
        <pre><code>
const inputRef = useRef(null);

&lt;input ref={inputRef} /&gt;
&lt;button onClick={() => inputRef.current.focus()}&gt;Enfocar&lt;/button&gt;
        </code></pre>
        <p><strong>Consideraciones avanzadas:</strong></p>
        <ul>
            <li><strong>Acceso al DOM:</strong> Usa <code>useRef</code> para acceder directamente a elementos del DOM.</li>
            <li><strong>Persistencia de valores:</strong> <code>useRef</code> es útil para almacenar valores que no deben provocar re-renderizados.</li>
            <li><strong>Integración con bibliotecas externas:</strong> Usa <code>useRef</code> para integrar bibliotecas que requieren acceso directo al DOM.</li>
        </ul>
        <p><strong>Ejemplo avanzado:</strong></p>
        <pre><code>
const ContadorRenderizados = () => {
  const renderizados = useRef(0);
  renderizados.current += 1;
  return &lt;p&gt;Renderizados: {renderizados.current}&lt;/p&gt;;
};
        </code></pre>
    </div>

    <!-- Sección 10: Contexto global con useContext -->
    <div class="section" id="useContext">
        <h2>10. Contexto global con useContext</h2>
        <p><strong>Definición:</strong> <code>useContext</code> es un hook que permite acceder al valor de un contexto de React dentro de un componente funcional, sin necesidad de pasar props manualmente a través de múltiples niveles.</p>
        <p><strong>Sintaxis:</strong></p>
        <pre><code>
const MiContexto = React.createContext(valorPorDefecto);

&lt;MiContexto.Provider value={valorCompartido}&gt;
  &lt;MiComponente /&gt;
&lt;/MiContexto.Provider&gt;

const valor = useContext(MiContexto);
        </code></pre>
        <p><strong>Consideraciones avanzadas:</strong></p>
        <ul>
            <li><strong>Re-renderizado automático:</strong> Cuando el valor del contexto cambia, todos los componentes que lo consumen se renderizan de nuevo.</li>
            <li><strong>Evitar sobreuso:</strong> No uses contexto para datos que cambian frecuentemente (como inputs).</li>
            <li><strong>Divide por dominios:</strong> Crea múltiples contextos especializados en lugar de uno general.</li>
            <li><strong>Combinar con useReducer:</strong> Excelente patrón para manejar estados globales con lógica compleja.</li>
        </ul>
        <p><strong>Ejemplo avanzado:</strong></p>
        <pre><code>
const TemaContexto = createContext("claro");

function App() {
  const [tema, setTema] = useState("claro");

  return (
    &lt;TemaContexto.Provider value={{ tema, setTema }}&gt;
      &lt;Encabezado /&gt;
      &lt;button onClick={() => setTema(tema === "claro" ? "oscuro" : "claro")}&gt;
        Cambiar tema
      &lt;/button&gt;
    &lt;/TemaContexto.Provider&gt;
  );
}
        </code></pre>
    </div>

    <!-- Sección 11: Navegación con React Router -->
    <div class="section" id="router">
        <h2>11. Navegación con React Router</h2>
        <p><strong>Definición:</strong> <code>react-router-dom</code> es la librería estándar de enrutamiento para React. Permite crear aplicaciones de una sola página (SPA) con múltiples rutas.</p>
        <p><strong>Ejemplo de rutas:</strong></p>
        <pre><code>
import { BrowserRouter, Routes, Route } from 'react-router-dom';

&lt;BrowserRouter&gt;
  &lt;Routes&gt;
    &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
    &lt;Route path="/perfil/:id" element={&lt;Perfil /&gt;} /&gt;
    &lt;Route path="*" element={&lt;NotFound /&gt;} /&gt;
  &lt;/Routes&gt;
&lt;/BrowserRouter&gt;
        </code></pre>
        <p><strong>Consideraciones avanzadas:</strong></p>
        <ul>
            <li><strong>Rutas protegidas:</strong> Implementa rutas protegidas para autenticar usuarios.</li>
            <li><strong>Redirecciones:</strong> Usa <code>&lt;Navigate /&gt;</code> para redireccionar a otras rutas.</li>
            <li><strong>Rutas dinámicas:</strong> Usa <code>useParams</code> para acceder a parámetros dinámicos.</li>
        </ul>
        <p><strong>Ejemplo avanzado:</strong></p>
        <pre><code>
const RutaProtegida = ({ children }) => {
  const { usuario } = useContext(AuthContext);
  return usuario ? children : &lt;Navigate to="/login" /&gt;;
};
        </code></pre>
    </div>

    <!-- Sección 12: Parámetros de ruta con useParams -->
    <div class="section" id="useParams">
        <h2>12. Parámetros de ruta con useParams</h2>
        <p><strong>Definición:</strong> <code>useParams</code> es un hook de <code>react-router-dom</code> que permite acceder a los parámetros dinámicos definidos en las rutas.</p>
        <p><strong>Ejemplo:</strong></p>
        <pre><code>
&lt;Route path="/usuario/:id" element={&lt;Perfil /&gt;} /&gt;

const { id } = useParams();
        </code></pre>
        <p><strong>Consideraciones avanzadas:</strong></p>
        <ul>
            <li><strong>Validación de parámetros:</strong> Valida siempre los parámetros antes de usarlos.</li>
            <li><strong>Rutas anidadas:</strong> Usa rutas anidadas para estructuras de navegación complejas.</li>
            <li><strong>Query strings:</strong> Usa <code>useSearchParams</code> para manejar query strings.</li>
        </ul>
        <p><strong>Ejemplo avanzado:</strong></p>
        <pre><code>
const Perfil = () => {
  const { id } = useParams();
  const [searchParams] = useSearchParams();
  const nombre = searchParams.get('nombre');

  return (
    &lt;div&gt;
      &lt;h2&gt;Perfil de {nombre}&lt;/h2&gt;
      &lt;p&gt;ID: {id}&lt;/p&gt;
    &lt;/div&gt;
  );
};
        </code></pre>
    </div>

    <!-- Sección 13: Estados complejos con useReducer -->
    <div class="section" id="useReducer">
        <h2>13. Estados complejos con useReducer</h2>
        <p><strong>Definición:</strong> <code>useReducer</code> es un hook que permite manejar estados complejos en componentes funcionales, utilizando el patrón reducer muy conocido en bibliotecas como Redux. Es una alternativa a <code>useState</code> cuando:</p>
        <ul>
            <li>El estado tiene una estructura compleja (objetos anidados, múltiples propiedades).</li>
            <li>Las actualizaciones de estado dependen del valor anterior.</li>
            <li>Hay múltiples acciones que modifican el mismo estado.</li>
        </ul>
        <p><strong>Sintaxis básica:</strong></p>
        <pre><code>const [state, dispatch] = useReducer(reducer, estadoInicial);</code></pre>
        <p><strong>Ejemplo de reducer:</strong></p>
        <pre><code>
function reducer(state, action) {
  switch (action.type) {
    case 'incrementar':
      return { contador: state.contador + 1 };
    case 'decrementar':
      return { contador: state.contador - 1 };
    default:
      return state;
  }
}
        </code></pre>
        <p><strong>Consideraciones avanzadas:</strong></p>
        <ul>
            <li><strong>Reducer como función pura:</strong> No debe modificar el estado original (inmutabilidad) ni realizar efectos secundarios (fetch, logs, etc.).</li>
            <li><strong>Desacoplamiento:</strong> La lógica del estado queda centralizada y separada del componente.</li>
            <li><strong>Escalabilidad:</strong> Ideal para estructuras de estado que crecen con el tiempo.</li>
            <li><strong>Testabilidad:</strong> Fácil de testear con tests unitarios al ser funciones puras.</li>
            <li><strong>Combinar con contextos:</strong> Se puede combinar con <code>useContext</code> para manejar estado global compartido entre componentes.</li>
        </ul>
        <p><strong>Ejemplo avanzado:</strong></p>
        <pre><code>
const estadoInicial = { contador: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'incrementar':
      return { contador: state.contador + 1 };
    case 'decrementar':
      return { contador: state.contador - 1 };
    default:
      return state;
  }
}

function ContadorReducer() {
  const [state, dispatch] = useReducer(reducer, estadoInicial);

  return (
    &lt;div&gt;
      &lt;h2&gt;Contador: {state.contador}&lt;/h2&gt;
      &lt;button onClick={() => dispatch({ type: 'incrementar' })}&gt;+&lt;/button&gt;
      &lt;button onClick={() => dispatch({ type: 'decrementar' })}&gt;-&lt;/button&gt;
    &lt;/div&gt;
  );
}
        </code></pre>
    </div>

    <!-- Sección 14: Persistencia con localStorage y sessionStorage -->
    <div class="section" id="storage">
        <h2>14. Persistencia con localStorage y sessionStorage</h2>
        <p><strong>Definición:</strong> <code>localStorage</code> y <code>sessionStorage</code> son APIs del navegador para guardar información en el cliente.</p>
        <p><strong>Sintaxis:</strong></p>
        <pre><code>
localStorage.setItem("clave", "valor");
localStorage.getItem("clave");
localStorage.removeItem("clave");
sessionStorage.setItem("clave", "valor");
        </code></pre>
        <p><strong>Consideraciones avanzadas:</strong></p>
        <ul>
            <li><strong>Persistencia de datos:</strong> <code>localStorage</code> persiste tras cerrar el navegador, mientras que <code>sessionStorage</code> se borra al cerrar la pestaña.</li>
            <li><strong>Seguridad:</strong> No almacenes datos sensibles (contraseñas, tokens) en <code>localStorage</code> o <code>sessionStorage</code>.</li>
            <li><strong>Serialización:</strong> Convierte objetos a JSON antes de almacenarlos.</li>
        </ul>
        <p><strong>Ejemplo avanzado:</strong></p>
        <pre><code>
const usuario = { nombre: "Juan", edad: 25 };
localStorage.setItem("usuario", JSON.stringify(usuario));
const usuarioGuardado = JSON.parse(localStorage.getItem("usuario"));
        </code></pre>
    </div>

    <!-- Sección 15: Introducción a React con TypeScript -->
    <div class="section" id="tsx">
        <h2>15. Introducción a React con TypeScript</h2>
        <p><strong>Definición:</strong> TSX es JSX con soporte para TypeScript, lo que añade tipado estático a tus componentes React.</p>
        <p><strong>Ventajas:</strong></p>
        <ul>
            <li>Autocompletado en editores.</li>
            <li>Validación de tipos en tiempo de compilación.</li>
            <li>Menor cantidad de bugs en producción.</li>
        </ul>
        <p><strong>Ejemplo de tipos:</strong></p>
        <pre><code>
interface Props {
  nombre: string;
  edad?: number;
}

const Saludo: React.FC&lt;Props&gt; = ({ nombre, edad }) => (
  &lt;p&gt;Hola {nombre}, edad: {edad}&lt;/p&gt;
);
        </code></pre>
        <p><strong>Consideraciones avanzadas:</strong></p>
        <ul>
            <li><strong>Tipos genéricos:</strong> Usa tipos genéricos para componentes reutilizables.</li>
            <li><strong>Tipos avanzados:</strong> Aprovecha tipos como <code>Union Types</code>, <code>Intersection Types</code> y <code>Conditional Types</code>.</li>
            <li><strong>Integración con hooks:</strong> Define tipos para los hooks como <code>useState</code> y <code>useReducer</code>.</li>
        </ul>
        <p><strong>Ejemplo avanzado:</strong></p>
        <pre><code>
interface Estado {
  contador: number;
}

type Accion = { type: 'incrementar' } | { type: 'decrementar' };

function reducer(state: Estado, action: Accion): Estado {
  switch (action.type) {
    case 'incrementar':
      return { contador: state.contador + 1 };
    case 'decrementar':
      return { contador: state.contador - 1 };
    default:
      return state;
  }
}
        </code></pre>
    </div>

</body>
</html>